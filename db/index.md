# テータベース工学-課題2

## 1. はじめに
データベースを用いたアプリケーションにおいて、インデックスはデータの検索性能を向上させる重要な要素である。
本記事では、PostgreSQLにおけるB-treeインデックスの作成とその効果について検証する。

## 2. インデックスとは
インデックスとは、テーブルとは別に保持される検索用のデータ構造であり、`WHERE` 句や `JOIN`、`ORDER BY` などで用いられる列に対して作成することで、目的の行を素早く見つけることを可能にする。  
書籍の「索引」と同様に、目的の項目へ直接たどり着くための手がかりを保持する仕組みである。

### 2.1 インデックスが扱う情報
一般的なインデックスは、次のような情報を保持する。

- **キー（索引キー）**: インデックス対象列の値（例: `price`）
- **参照先（ポインタ）**: 該当するテーブル行の位置を示す情報

これにより、条件に合致するキーをインデックス上で探索し、該当行だけをテーブルから取り出せる。

### 2.2 インデックスがない場合との違い
インデックスが存在しない場合、`WHERE` 句の条件に一致する行を探すには、基本的にテーブル全体を順に確認する必要があり、計算量は概ね $O(n)$ となる（Seq Scan / 全表走査）。  
一方でB-treeインデックスを利用できる条件（等価検索や範囲検索など）では、木構造を辿って探索できるため計算量は概ね $O(\log n)$ に近づき、大規模データほど効果が出やすい。

### 2.3 利点とコスト（トレードオフ）
インデックスには利点だけでなくコストもあるため、作成対象は慎重に選ぶ必要がある。

- **利点**: 検索・結合・並び替え（条件による）を高速化できる
- **コスト**:  
  - インデックス自体のディスク使用量が増える  
  - `INSERT / UPDATE / DELETE` のたびにインデックスも更新されるため、更新性能が低下する場合がある  
  - 最適化の観点では、選択性が低い列などでは効果が出にくいことがある

### 2.4 PostgreSQLでよく使われるB-treeインデックス
PostgreSQLではB-treeインデックスが最も一般的に利用される。  
B-treeは 等価検索（`=`） と 範囲検索（`<`, `<=`, `BETWEEN`, `>`） に強く、また並び順を利用できるため、条件によっては `ORDER BY` のソートコスト削減にも寄与する。  
以降では、このB-treeインデックスの構造と、実際に作成したときの効果を検証する。

## 3. B-treeの構造
B-treeは、平衡木構造の一種であり、ノードが複数の子ノードを持つことができる。これにより、データの挿入、削除、検索操作が効率的に行える。B-treeは、データベースシステムにおいて広く採用されており、その性能と信頼性が評価されている。

### 3.1 B-tree（正確にはB+tree）の基本概念
PostgreSQLのB-treeインデックスは、一般に「B-tree」と呼ばれるが、実装としてはB+tree系の構造である（実務上はB-treeと呼称されることが多い）。  
B+treeでは、実データ（テーブル行）への参照は主に葉ノードに格納され、内部ノードは「どの方向へ降りればよいか」を示す案内（境界キー）を保持する。これにより、範囲検索や並び順の走査が効率化される。

### 3.2 ノード構造と平衡性（Balanced）
B-treeは高さが一定に保たれる（平衡である）ことが特徴である。
各ノードは複数のキーを保持し、キーの範囲によって子ノードへ分岐する。データ件数が増えても木の高さはゆっくり増えるため、探索コストは概ね O(log n) に抑えられる。

- **内部ノード**: 「キー境界」と「子ノードへのポインタ」を持つ（探索の分岐に使用）
- **葉ノード**: 「キー」と「テーブル行への参照（TIDなど）」を持つ
- **平衡**: すべての葉は同じ深さにあり、極端に片寄った木になりにくい

### 3.3 探索（検索）が速い理由
B-tree検索では、ルートから内部ノードを辿り、条件に合う葉ノードへ到達する。  
たとえば `price BETWEEN 5000 AND 6000` のような条件では、まず `5000` 付近の葉ノードを特定し、そこから葉ノードの連結（右方向へのリンク）を利用して範囲内を連続的に走査できる。これにより、広範囲の全表走査を避けやすい。

### 3.4 挿入・分割（split）と削除
B-treeは更新に強く、データ追加が続いても性能が劣化しにくいように設計されている。

- **挿入（INSERT）**: 追加先の葉ノードに空きがあれば挿入する。
- **ページ分割（split）**: 葉ノードが満杯の場合、ノードを分割してキーを再配分し、上位ノードに境界キーを追加する。これにより木の高さを保ちつつ拡張できる。
- **削除（DELETE）**: 一般に即座に大規模な再構成は行わず、必要に応じて整理される。ノードのキーが少なくなりすぎた場合は、隣接ノードと結合することもある。

## 4. インデックスが有効なケース・有効でないケース
インデックスはすべてのクエリで有効とは限らない。以下に、インデックスが有効なケースと有効でないケースを示す。
### 4.1 インデックスが有効なケース
#### 4.1.1 範囲検索
B-treeインデックスは、`BETWEEN`や`<`, `>`などの範囲検索に対して非常に効果的である。<br>
例: `WHERE price BETWEEN 5000 AND 6000`

#### 4.1.2 等価検索
特定の値に対する等価検索もインデックスの恩恵を受けやすい。<br>
例: `WHERE item_id = 12345`

### 4.2 インデックスが有効でないケース
#### 4.2.1 小規模テーブル
小規模なテーブルでは、インデックスのオーバーヘッドがパフォーマンスを低下させることがある。全表走査の方が速い場合もある。<br>
例: テーブルに数百行しかない場合

#### 4.2.2 インデックス列に対する関数適用
インデックス列に対して関数が適用される場合、インデックスが利用されないことがある。<br>
例: `WHERE LOWER(name) = 'example'`

#### 4.2.3 IS NULL検索
NULL値に対する検索では、インデックスが効果的でない場合がある。<br>
例: `WHERE column IS NULL`

#### 4.2.4 否定条件
否定条件（`NOT`）を含むクエリでは、インデックスが利用されにくい。<br>
例: `WHERE price <> 1000`

#### 4.2.5 高い選択性を持たない列
選択性が低い列（多くの行が同じ値を持つ列）に対するインデックスは、パフォーマンス向上に寄与しないことがある。<br>
例: `WHERE is_active = true`（多くの行がtrueの場合）

#### 4.2.6 頻繁な更新
頻繁にデータが挿入・更新・削除されるテーブルでは、インデックスの維持コストが高くなり、パフォーマンスが低下することがある。

## 5. 実験
### 5.1 環境設定
PostgreSQLデータベースを使用し、以下のSQLスクリプトを実行してテーブルを作成する。

```sql
CREATE EXTENSION IF NOT EXISTS pgcrypto;

START TRANSACTION;

DROP TABLE IF EXISTS k_items;

CREATE TABLE k_items (
  item_id SERIAL PRIMARY KEY,
  price INTEGER NOT NULL,
  qty INTEGER NOT NULL,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- サンプルデータを10^8件挿入
INSERT INTO
  k_items (price, qty, created_at)
SELECT
  (RANDOM() * 10000)::INTEGER AS price,
  (RANDOM() * 100)::INTEGER AS qty,
  NOW() - (RANDOM() * INTERVAL '365 days') AS created_at
FROM
  GENERATE_SERIES(1, 100000000);
COMMIT;
```

このスクリプトは、`k_items`というテーブルを作成し、1億件のサンプルデータを挿入する。
各レコードは、`price`（価格）、`qty`（在庫数）、および`created_at`（作成日時）を含む。
`price`は0から10000の範囲、`qty`は0から100の範囲の整数ででランダムに生成される。

### 5.2 インデックス作成前のクエリ実行
インデックスを作成する前に、以下のクエリを実行してパフォーマンスを測定する。

```sql
EXPLAIN
ANALYZE
SELECT
  *
FROM
  k_items
WHERE
  price BETWEEN 5000 AND 6000  AND
  qty >= 90;
```

### 5.3 インデックス作成
次に、B-treeインデックスを作成する。

```sql
-- B-tree インデックスの作成
CREATE INDEX idx_k_items_price_qty ON k_items (price, qty);
```

### 5.4 インデックス作成後のクエリ実行
インデックス作成後に、同じクエリを再度実行してパフォーマンスを測定する。

```sql
EXPLAIN
ANALYZE
SELECT
  *
FROM
  k_items
WHERE
  price BETWEEN 5000 AND 6000  AND
  qty >= 90;
```

## 6. 結果と考察
インデックス作成前後のクエリ実行計画を比較すると、以下のような結果が得られた。
インデックス作成前:
```
                                                             QUERY PLAN
------------------------------------------------------------------------------------------------------------------------------------
 Gather  (cost=1000.00..1445533.63 rows=180467 width=20) (actual time=50.585..3288.924 rows=1052827 loops=1)
   Workers Planned: 2
   Workers Launched: 2
   ->  Parallel Seq Scan on k_items  (cost=0.00..1426486.93 rows=75195 width=20) (actual time=47.631..3243.023 rows=350942 loops=3)
         Filter: ((price >= 5000) AND (price <= 6000) AND (qty >= 90))
         Rows Removed by Filter: 32982391
 Planning Time: 0.629 ms
 JIT:
   Functions: 6
   Options: Inlining true, Optimization true, Expressions true, Deforming true
   Timing: Generation 0.422 ms (Deform 0.110 ms), Inlining 114.464 ms, Optimization 13.002 ms, Emission 15.300 ms, Total 143.189 ms
 Execution Time: 3331.397 ms
(12 行)
```

インデックス作成後:
```
                                                             QUERY PLAN
-------------------------------------------------------------------------------------------------------------------------------------
 Gather  (cost=1000.00..1469102.92 rows=1019929 width=20) (actual time=53.844..1132.265 rows=1052827 loops=1)
   Workers Planned: 2
   Workers Launched: 2
   ->  Parallel Seq Scan on k_items  (cost=0.00..1366110.02 rows=424970 width=20) (actual time=53.062..1101.645 rows=350942 loops=3)
         Filter: ((price >= 5000) AND (price <= 6000) AND (qty >= 90))
         Rows Removed by Filter: 32982391
 Planning Time: 0.253 ms
 JIT:
   Functions: 6
   Options: Inlining true, Optimization true, Expressions true, Deforming true
   Timing: Generation 0.502 ms (Deform 0.115 ms), Inlining 137.902 ms, Optimization 8.944 ms, Emission 12.143 ms, Total 159.490 ms
 Execution Time: 1170.793 ms
```

クエリ実行時間は、インデックス作成前の約3331msからインデックス作成後の約1170msへと大幅に短縮された。
<!-- これは、B-treeインデックスが検索性能を向上させたことを示している。 -->

## 7. 結論
本記事では、PostgreSQLにおけるB-treeインデックスの作成とその効果について検証した。インデックスを作成することで、クエリの実行時間が大幅に短縮され、検索性能が向上することが確認できた。データベース設計において、適切なインデックスの使用は重要であり、パフォーマンス最適化に寄与することが示された。また、本記事では省略しているが、テーブルに投入するサンプルデータの行数が100万行であった場合は、インデックス作成前後のパフォーマンスに大きな差は見られなかった。これは、データ量が少ない場合、インデックスの利点が十分に発揮されないためであると考えられる。したがって、インデックスの効果はデータ量に依存することも考慮する必要がある。

## 8. 参考文献
- ミック. 達人に学ぶDB設計徹底指南書 第2版. 翔泳社, 2024, pp. 188-205.
- Kiyoto Yamaura. "B-treeインデックス入門". Qiita. 2014-12-12. https://qiita.com/kiyodori/items/f66a545a47dc59dd8839, (参照 2026-01-24).
- farstep. "【データベース基礎】インデックスの仕組みを理解する（初学者向け）". Zenn. 2025-02-23. https://zenn.dev/farstep/books/learn-database-index-basics, (参照 2026-01-24).

本コンテンツの作成時間：約5時間